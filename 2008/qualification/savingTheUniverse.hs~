type Engine = String
type Query = String

data CaseState = CaseState { engines :: [Engine]
                           , queries :: [Query]
                           , swaps :: Int }



readTestCase :: IO (CaseState)
readTestCase = do
  searchEngines <- (read getLine) :: Int
  engines <- replicateM searchEngines getLine

  numQueries <- (read getLine) :: Int
  queries <- replicateM numQueries getLine
  
  return CaseState { engines = engines
                   , queries = queries
                   , swaps = 0 }

updateEngines :: CaseState -> CaseState
updateEngines caseState = caseState { engines = newEs
                                    , queries = newQs }
  where
    qLength = length $ queries caseState

    nextQ = if qLength > 0
            then head $ queries caseState
            else []
    es = engines caseState
    newEs = delete nextQ es
    
    newQs = if qLength  > 0
            then tail $ queries caseState
            else []

evalCase :: CaseState -> CaseState
evalCase caseState = until (null . queries) stepState
  where
    checkState CaseState { queries = qs } = length qs == 0
    stepState
      CaseState { engines = es
                , queries = qs} = until (null . engines) updateEngines 
    
    queriesLeft = dropWhileAccum pred engines queries
    pred es q | q `in` es = (newEs, newEs /= [])
              | otherwise = (es, True)
      where newEs = delete q es

dropWhileAccum :: (a -> b -> (a, Bool)) -> a -> [b] -> [b]
dropWhileAccum _ _ [] = []
dropWhileAccum f a x:xs = if continue
                          then dropWhileAccum newA xs
                          else x:xs
  where
    (newA, continue) = f a x

main = do
  testCases <- (read getLine) :: Int
  cases <- replicateM testCases readTestCase
  map calcSwaps cases


{-

BlackList
-Yeehaw
-Googol
-B9
-NSM
-Dont Ask

-}
